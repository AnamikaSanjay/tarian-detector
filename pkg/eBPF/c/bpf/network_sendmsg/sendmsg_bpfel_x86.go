// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64

package network_sendmsg

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type sendmsgEventData struct {
	EventContext struct {
		Ts        uint64
		StartTime uint64
		Pid       uint32
		Tgid      uint32
		Ppid      uint32
		Glpid     uint32
		Uid       uint32
		Gid       uint32
		Comm      [16]uint8
		Cwd       [32]uint8
		CgroupId  uint64
		NodeInfo  struct {
			Sysname    [65]uint8
			Nodename   [65]uint8
			Release    [65]uint8
			Version    [65]uint8
			Machine    [65]uint8
			Domainname [65]uint8
		}
		MountInfo struct {
			MountId      int32
			MountNsId    uint32
			MountDevname [256]uint8
		}
	}
	_          [2]byte
	Id         int32
	Fd         int32
	Len        uint64
	Flags      uint32
	MsgNamelen int32
	MsgName    [64]uint8
	MsgIovlen  uint64
	Ret        int32
	_          [4]byte
}

// loadSendmsg returns the embedded CollectionSpec for sendmsg.
func loadSendmsg() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_SendmsgBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load sendmsg: %w", err)
	}

	return spec, err
}

// loadSendmsgObjects loads sendmsg and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*sendmsgObjects
//	*sendmsgPrograms
//	*sendmsgMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadSendmsgObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadSendmsg()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// sendmsgSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type sendmsgSpecs struct {
	sendmsgProgramSpecs
	sendmsgMapSpecs
}

// sendmsgSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type sendmsgProgramSpecs struct {
	KprobeSendmsgEntry   *ebpf.ProgramSpec `ebpf:"kprobe_sendmsg_entry"`
	KretprobeSendmsgExit *ebpf.ProgramSpec `ebpf:"kretprobe_sendmsg_exit"`
}

// sendmsgMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type sendmsgMapSpecs struct {
	SendmsgEventMap *ebpf.MapSpec `ebpf:"sendmsg_event_map"`
}

// sendmsgObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadSendmsgObjects or ebpf.CollectionSpec.LoadAndAssign.
type sendmsgObjects struct {
	sendmsgPrograms
	sendmsgMaps
}

func (o *sendmsgObjects) Close() error {
	return _SendmsgClose(
		&o.sendmsgPrograms,
		&o.sendmsgMaps,
	)
}

// sendmsgMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadSendmsgObjects or ebpf.CollectionSpec.LoadAndAssign.
type sendmsgMaps struct {
	SendmsgEventMap *ebpf.Map `ebpf:"sendmsg_event_map"`
}

func (m *sendmsgMaps) Close() error {
	return _SendmsgClose(
		m.SendmsgEventMap,
	)
}

// sendmsgPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadSendmsgObjects or ebpf.CollectionSpec.LoadAndAssign.
type sendmsgPrograms struct {
	KprobeSendmsgEntry   *ebpf.Program `ebpf:"kprobe_sendmsg_entry"`
	KretprobeSendmsgExit *ebpf.Program `ebpf:"kretprobe_sendmsg_exit"`
}

func (p *sendmsgPrograms) Close() error {
	return _SendmsgClose(
		p.KprobeSendmsgEntry,
		p.KretprobeSendmsgExit,
	)
}

func _SendmsgClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed sendmsg_bpfel_x86.o
var _SendmsgBytes []byte
